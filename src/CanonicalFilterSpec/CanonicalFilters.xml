<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://docbook.org/ns/docbook ../../lib/docbook-5/xsd/docbook.xsd " xml:id="canonfilters">
	<title>Canonical Filter Specification</title>

	<para>
		The canonical filter specification allows a more fine grained definition for message matching and substitution
		actions.
	</para>

	<section>
		<title>Syntax</title>

		<para>
			The basic syntax for the canonical filter elements in shown in
			<xref xlink:href="#canonfilters.syntax.template" />
			. The complete syntax is described by the grammar defined in
			<xref xlink:href="#canonfilters.grammar" />
			.
		</para>

		<example xml:id="canonfilters.syntax.template">
			<title>Canonical Filter Definition Template</title>
			<programlistingco>
				<areaspec>
					<area coords="1 47" xml:id="canonfilters.syntax.template.filter" />
					<area coords="2 22" xml:id="canonfilters.syntax.template.expr" />
					<area coords="4 14" xml:id="canonfilters.syntax.template.assignments" />
					<area coords="7 5" xml:id="canonfilters.syntax.template.oper" />
					<area coords="7 28" xml:id="canonfilters.syntax.template.noexpr" />
				</areaspec>
				<programlisting language="composestar" xml:space="preserve">FilterName : FilterType ( FilterArguments ) = 
	( MatchingExpression )
	{
		Assignment;
		Assignment;
	}
	cor ( MatchingExpression )
</programlisting>
			</programlistingco>
			<calloutlist>
				<callout arearefs="canonfilters.syntax.template.filter">
					<para>
						The filter declaration for canonical filters is identical to the notation used for the classical
						filters.
					</para>
				</callout>
				<callout arearefs="canonfilters.syntax.template.expr">
					<para>
						The expression that needs to evaluate to true for the message to be accepted by the current
						filter definition. The syntax for these expressions will be explained in
						<xref xlink:href="#canonfilters.syntax.matchexpr" />
						.
					</para>
				</callout>
				<callout arearefs="canonfilters.syntax.template.assignments">
					<para>
						Assignments to be performed when the message matches. Assignments will be further discussed in
						<xref xlink:href="#canonfilters.syntax.assignments" />
						.
					</para>
				</callout>
				<callout arearefs="canonfilters.syntax.template.oper">
					<para>
						The operators that links multiple filter elements in a filter definition. Currently there is
						only a single operator defined, namely the conditional
						<emphasis>or</emphasis>
						operator:
						<function>cor</function>
						.
					</para>
				</callout>
				<callout arearefs="canonfilters.syntax.template.noexpr">
					<para>
						The assignment part is optional. When not assignments are needed this block can simply be
						omitted. An empty assignment block is also allowed.
					</para>
				</callout>
			</calloutlist>
		</example>

		<productionset xml:id="canonfilters.grammar">
			<title>Canonical Filter Grammar</title>

			<production>
				<lhs>Filter</lhs>
				<rhs>
					Identifier ':' FilterType '='
					<nonterminal def="#canonfilters.grammar.CanonFilterElms">CanonFilterElms</nonterminal>
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.CanonFilterElms">
				<lhs>CanonFilterElms</lhs>
				<rhs>
					<nonterminal def="#canonfilters.grammar.CanonFilterElm">CanonFilterElm</nonterminal>
					{
					<nonterminal def="#canonfilters.grammar.CanonFilterElmOp">CanonFilterElmOp</nonterminal>
					<nonterminal def="#canonfilters.grammar.CanonFilterElm">CanonFilterElm</nonterminal>
					}
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.CanonFilterElmOp">
				<lhs>CanonFilterElmOp</lhs>
				<rhs>'cor'</rhs>
			</production>

			<production xml:id="canonfilters.grammar.CanonFilterElm">
				<lhs>CanonFilterElm</lhs>
				<rhs>
					'('
					<nonterminal def="#canonfilters.grammar.MatchingExpression">MatchingExpression</nonterminal>
					')' [ '{' {
					<nonterminal def="#canonfilters.grammar.CanonAssignment">CanonAssignment</nonterminal>
					} '}' ]
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.MatchingExpression">
				<lhs>MatchingExpression</lhs>
				<rhs>
					<nonterminal def="#canonfilters.grammar.AndExpr">AndExpr</nonterminal>
					[ '|'
					<nonterminal def="#canonfilters.grammar.MatchingExpression">MatchingExpression</nonterminal>
					]
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.AndExpr">
				<lhs>AndExpr</lhs>
				<rhs>
					<nonterminal def="#canonfilters.grammar.UnaryExpr">UnaryExpr</nonterminal>
					[ '&amp;'
					<nonterminal def="#canonfilters.grammar.AndExpr">AndExpr</nonterminal>
					]
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.UnaryExpr">
				<lhs>UnaryExpr</lhs>
				<rhs>
					['!'] (
					<nonterminal def="#canonfilters.grammar.Operand">Operand</nonterminal>
					| '('
					<nonterminal def="#canonfilters.grammar.CompExpr">CompExpr</nonterminal>
					')' ) |
					<nonterminal def="#canonfilters.grammar.MatchingExpression">MatchingExpression</nonterminal>
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.Operand">
				<lhs>Operand</lhs>
				<rhs>'True' | 'False' | Identifier</rhs>
			</production>

			<production xml:id="canonfilters.grammar.CompExpr">
				<lhs>CompExpr</lhs>
				<rhs>
					<nonterminal def="#canonfilters.grammar.BaseMessage">BaseMessage</nonterminal>
					<nonterminal def="#canonfilters.grammar.CompExprOp">CompExprOp</nonterminal>
					<nonterminal def="#canonfilters.grammar.CompExprRhs">CompExprRhs</nonterminal>
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.CompExprOp">
				<lhs>CompExprOp</lhs>
				<rhs>'==' | '$=' | '~=' | '@='</rhs>
			</production>

			<production xml:id="canonfilters.grammar.BaseMessage">
				<lhs>BaseMessage</lhs>
				<rhs>'target' | 'selector' | 'message.' ( 'target' | 'selector' | 'server' | 'sender' | 'self' )</rhs>
			</production>

			<production xml:id="canonfilters.grammar.CompExprRhs">
				<lhs>CompExprRhs</lhs>
				<rhs>
					<nonterminal def="#canonfilters.grammar.ListOfCompExprRhs">ListOfCompExprRhs</nonterminal>
					|
					<nonterminal def="#canonfilters.grammar.SingleCompExprRhs">SingleCompExprRhs</nonterminal>
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.ListOfCompExprRhs">
				<lhs>ListOfCompExprRhs</lhs>
				<rhs>
					'['
					<nonterminal def="#canonfilters.grammar.SingleCompExprRhs">SingleCompExprRhs</nonterminal>
					{ ','
					<nonterminal def="#canonfilters.grammar.SingleCompExprRhs">SingleCompExprRhs</nonterminal>
					} ']'
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.SingleCompExprRhs">
				<lhs>SingleCompExprRhs</lhs>
				<rhs>
					FullyQualifiedName |
					<nonterminal def="#canonfilters.grammar.Literal">Literal</nonterminal>
					| 'inner' | FilterModuleParameter |
					<nonterminal def="#canonfilters.grammar.BaseMessage">BaseMessage</nonterminal>
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.Literal">
				<lhs>Literal</lhs>
				<rhs>''' ? string data ? ''' | '"' ? string data ? '"'</rhs>
			</production>

			<production xml:id="canonfilters.grammar.CanonAssignment">
				<lhs>CanonAssignment</lhs>
				<rhs>
					<nonterminal def="#canonfilters.grammar.AssignmentLhs">AssignmentLhs</nonterminal>
					'='
					<nonterminal def="#canonfilters.grammar.AssignmentRhs">AssignmentRhs</nonterminal>
					';'
				</rhs>
			</production>

			<production xml:id="canonfilters.grammar.AssignmentLhs">
				<lhs>AssignmentLhs</lhs>
				<rhs>'target' | 'selector' | ( 'message.' Identifier ) | ('filter.' Identifier)</rhs>
			</production>

			<production xml:id="canonfilters.grammar.AssignmentRhs">
				<lhs>AssignmentRhs</lhs>
				<rhs>
					'target' | 'selector' | ( 'message.' Identifier ) | ('filter.' Identifier) | FullyQualifiedName |
					<nonterminal def="#canonfilters.grammar.Literal">Literal</nonterminal>
					| 'inner' | FilterModuleParameter
				</rhs>
			</production>

		</productionset>

		<section xml:id="canonfilters.syntax.matchexpr">
			<title>Matching Expressions</title>
			<para>
				A matching expression is an expression that evaluates to a boolean value. The matching expression
				defines if a message is accepted by the current filter. Only when the message is accepted the filter
				will be executed.
			</para>
			<para>
				The expression is a combination of condition references and compare statements combined with boolean
				operators like
				<emphasis>or</emphasis>
				(
				<code>true | false</code>
				) ,
				<emphasis>and</emphasis>
				(
				<code>true &amp; false</code>
				) and
				<emphasis>not</emphasis>
				(
				<code>!true</code>
				) . Sub-expressions can be created using parenthesis:
				<code>(true | !(true &amp; false))</code>
				.
			</para>
			<para>
				Condition references are the names to conditions as defined in the current filter modules. Besides
				condition references there are also to the constants
				<constant>true</constant>
				and
				<constant>false</constant>
				.
			</para>
			<para>
				The compare statements check if of a message property to matches with a given value. Compare statements
				have consist of three parts: left hand side, matching operator, and the right hand side. The following
				matching operators have been defined:
				<variablelist>
					<varlistentry>
						<term>
							Instance/name matching (
							<code language="composestar">==</code>
							)
						</term>
						<listitem>
							<simpara>
								Returns true when both sides are the same instance (for objects) or have the same name
								(for selectors).
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							Signature matching (
							<code language="composestar">$=</code>
							)
						</term>
						<listitem>
							<simpara>
								Returns true when the right hand side contains the signature implied by the left had
								side.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							Compatibility matching (
							<code language="composestar">~=</code>
							)
						</term>
						<listitem>
							<simpara>Returns true when both sides are compatible.</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							Annotation matching (
							<code language="composestar">@=</code>
							)
						</term>
						<listitem>
							<simpara>
								Returns true of the left hand side contains the annotation as identifier by the right
								hand side.
							</simpara>
						</listitem>
					</varlistentry>
				</variablelist>
				More information about the semantics of these operators in explained in ... . To negate a compare
				statement it needs to be wrappen in a subexpression:
				<code language="composestar">!(target == inner)</code>
				. The right hand side of the matching operator can contain a list of elements. The list is created by
				enclosing a comma separated list of elements with square brackets. With a list the compare statement
				will be
				<code>true</code>
				when the left hand side matches with at least one element from the list. For example, the following two
				matching expressions are identical:
				<programlisting language="composestar"><![CDATA[(selector == 'foo' | selector == 'bar' | selector == ?quux)
(selector == ['foo', 'bar', ?quux])]]></programlisting>
			</para>
		</section>

		<section xml:id="canonfilters.syntax.assignments">
			<title>Assignments</title>
			<para>
				The assignment part contains entries where message and filter properties are assigned new values. The
				syntax is much like flat configuration files:
				<code language="composestar">someVariable = newValue;</code>
				. The available variables and allowed values are discussed in ... .
			</para>
			<para>
				The assignment part of a filter element can contain zero or more assignments. The whole block can be
				omitted when no assignments are needed. Each assignment is terminated with a semicolon (
				<code>;</code>
				). The value only contains a simple new value, there are no expressions possible.
			</para>
		</section>

	</section>

	<section xml:id="canonfilters.semantics">
		<title>Semantics</title>
		<para></para>

		<section xml:id="canonfilters.semantics.types">
			<title>Types</title>
			<para>
				There are a couple of different types used in both the matching expressions and assignment part. These
				types determine how certain elements work.
			</para>
			<variablelist>
				<varlistentry>
					<term>Object</term>
					<listitem>
						<para>
							Or rather,
							<emphasis>instance</emphasis>
							. Variables of the type object are:
							<simplelist type="inline">
								<member>internals</member>
								<member>externals</member>
								<member>
									<code language="composestar">target</code>
								</member>
								<member>
									<code language="composestar">inner</code>
								</member>
								<member>
									<code language="composestar">message.target</code>
								</member>
								<member>
									<code language="composestar">message.sender</code>
								</member>
								<member>
									<code language="composestar">message.self</code>
								</member>
								<member>
									<code language="composestar">message.server</code>
								</member>
							</simplelist>
							New objects can be created through internals and externals in the current filter module,
							otherwise only the existing objects (see the previously mentioned list) can be used.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Selector</term>
					<listitem>
						<para>
							Only the variable
							<code language="composestar">selector</code>
							(and therefore
							<code language="composestar">message.selector</code>
							) has this type. A selector is much like a method signature, except that the selector can
							contain wildcards for the return type and accepted arguments.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Literal</term>
					<listitem>
						<para>
							A literal is a string enclosed by quotes (double quotes are allowed). For example:
							<code language="composestar">'this is a literal'</code>
							or
							<code language="composestar">"this is also a string"</code>
							. Literals are used
							<emphasis>as is</emphasis>
							, no preprocessing is performed on these values.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Fully Qualified Name (FQN)</term>
					<listitem>
						<para>
							A fully qualified name is resolved to a program element using the language model of the base
							program. A FQN is a combination of identifiers and periods, for example:
							<code language="composestar">thisIsAFQN</code>
							or
							<code language="composestar">this.is.also.a.fully.qualifiedName</code>
							. A FQN looks much like a reference to an internal/external/condition, they also use an
							identifier. Locally declared identifiers have precedence over fully qualified name. This
							means that if a identifier is encountered in either the matching expression or assignment
							part, it will be looked up in the existing name table for internals/externals/conditions and
							predefined variables (like:
							<code language="composestar">target</code>
							,
							<code language="composestar">selector</code>
							,
							<code language="composestar">message.*</code>
							, etc.).
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>Program Elements</term>
					<listitem>
						<para>
							Program elements can not be entered directly in the source code. Program elements are
							entities in the language model of the base program which is created during compilation.
							Program elements are only indirectly available through a lookup, a lookup can be created
							through a FQN or through filter module parameters. A filter module parameter can contain a
							(set of) program elements when it was passed a superimposition selector. Filter module
							conditions can also be used as a program element (in this case a method program elements),
							but only at places where program elements can be used.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>

			<example xml:id="canonfilters.semantics.types.example">
				<title>Usage of different types</title>
				<programlistingco>
					<areaspec>
						<area coords="8 23" xml:id="canonfilters.semantics.types.example.internal" />
						<area coords="9 23" xml:id="canonfilters.semantics.types.example.condition" />
						<area coords="10 33" xml:id="canonfilters.semantics.types.example.fqnTypo" />
						<area coords="11 34" xml:id="canonfilters.semantics.types.example.target" />
						<area coords="12 38" xml:id="canonfilters.semantics.types.example.fqn" />
						<area coords="13 34" xml:id="canonfilters.semantics.types.example.literal" />
						<area coords="14 28" xml:id="canonfilters.semantics.types.example.fmparam" />
					</areaspec>
					<programlisting language="composestar"><![CDATA[filtermodule ExampleFM(?myParam) {
	internals
		foo : FQNExample.MyClass;
	conditions
		bar : foo.test();
	inputfilters
		f1 : Dispatch = ( true ) {
			filter.item1 = foo;
			filter.item2 = bar;
			filter.item3 = filters.item1;
			filter.item4 = message.target;
			filter.item5 = FQNExample.MyClass;
			filter.item6 = 'hello world!';
			filter.item7 = ?myParam;
		}
}]]></programlisting>
					<calloutlist>
						<callout arearefs="canonfilters.semantics.types.example.internal">
							<simpara>
								<code language="composestar">filter.item1</code>
								will contain a value of type object.
								<code language="composestar">foo></code>
								refers to an internal, which is an instance of the class
								<code language="composestar">FQNExample.MyClass</code>
								.
							</simpara>
						</callout>
						<callout arearefs="canonfilters.semantics.types.example.condition">
							<simpara>
								<code language="composestar">bar</code>
								is a condition registered in this filter module, a condition is a reference to a method,
								therefore
								<code language="composestar">filter.item2</code>
								will contain a value of the type program elements. More sepecifically a method program
								elements.
							</simpara>
						</callout>
						<callout arearefs="canonfilters.semantics.types.example.fqnTypo">
							<simpara>
								<code language="composestar">filters.something</code>
								contains a typo, my mistake an
								<emphasis>s</emphasis>
								was added to the word
								<code language="composestar">filter</code>
								. As a result
								<code language="composestar">filters.item1</code>
								is regarded as a FQN and will be resolved in the language model of the base program.
								When no such element can be found a warning will be issued, and the resulting value is
								<emphasis>void</emphasis>
								.
							</simpara>
						</callout>
						<callout arearefs="canonfilters.semantics.types.example.target">
							<simpara>
								<code language="composestar">message.target</code>
								is an object, therefore the value of
								<code language="composestar">filter.item4</code>
								will be of type object.
							</simpara>
						</callout>
						<callout arearefs="canonfilters.semantics.types.example.fqn">
							<simpara>
								The current filter module does not contain a declaration with the name
								<code language="composestar">FQNExample.MyClasst</code>
								, so this entry is considered to be a fully qualified name and is resolved to a program
								element. This program element resolved to a type, not to an object. An object is an
								instance of a type, and instances are not present in the language model.
							</simpara>
						</callout>
						<callout arearefs="canonfilters.semantics.types.example.literal">
							<simpara>
								<code language="composestar">'hello world!'</code>
								is a literal,
								<code language="composestar">filter.item6</code>
								will contain exactly that value (without the quotes).
							</simpara>
						</callout>
						<callout arearefs="canonfilters.semantics.types.example.fmparam">
							<simpara>
								<code language="composestar">?myParam</code>
								is a filter module parameter. Its contents is unknown. Therefore the value of
								<code language="composestar">filter.item7</code>
								will not be known until this filter module has been instantiated. The value will most
								likely be a program element or a literal.
							</simpara>
						</callout>
					</calloutlist>
				</programlistingco>
			</example>

		</section>

		<section xml:id="canonfilters.semantics.matchexpr">
			<title>Matching Expression</title>
			<para></para>
		</section>

		<section xml:id="canonfilters.semantics.assignments">
			<title>Assignments</title>
			<para>
				In the assignment certain variables can be given a new value. Not all variables can be assigned a new
				value. Below is an overview of all variables, if they can be written and what types they accept for
				assignment.
			</para>

			<table frame="all" rules="all">
				<caption>Variable assignments</caption>
				<thead>
					<tr>
						<th>Variable</th>
						<th>Writable</th>
						<th>Accepted Type</th>
						<th>Comment</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>target</code>
							/
							<code>message.target</code>
						</td>
						<td>Yes</td>
						<td>Object</td>
						<td>
							A target always points to an object instance, therefore it can only accept objects as new
							value. So on the right hand side of the assignment operator can for example be a reference
							to an internal, external,
							<code>inner</code>
							.
						</td>
					</tr>
					<tr>
						<td rowspan="3">
							<code>selector</code>
							/
							<code>message.selector</code>
						</td>
						<td rowspan="3">Yes</td>
						<td>Literal</td>
						<td>
							The literal is converted to a selector with the return value and arguments set to a
							wildcard. This is the most common assignment for selectors, and the only way to directly set
							a new value for a selector in the source code.
						</td>
					</tr>
					<tr>
						<td>Program Element (Method)</td>
						<td>
							The program element is converted to a selector. This selector is more specific than the
							selector created from the literal. This selector has complete information regarding the
							return type and accepted arguments.
						</td>
					</tr>
					<tr>
						<td>Selector</td>
						<td>
							The selector variable has the type selector, so it can always be assigned a different
							selector value. Because selectors can not be directly created assigning a new selector can
							only be done by first saving a selector in a message property.
						</td>
					</tr>
					<tr>
						<td>
							<code>inner</code>
						</td>
						<td>No</td>
						<td></td>
						<td></td>
					</tr>
					<tr>
						<td>
							<code>message.sender</code>
						</td>
						<td>No</td>
						<td></td>
						<td></td>
					</tr>
					<tr>
						<td>
							<code>message.server</code>
						</td>
						<td>No</td>
						<td></td>
						<td></td>
					</tr>
					<tr>
						<td>
							<code>message.self</code>
						</td>
						<td>No</td>
						<td></td>
						<td></td>
					</tr>
					<tr>
						<td>
							<code>message.sender</code>
						</td>
						<td>No</td>
						<td></td>
						<td></td>
					</tr>
					<tr>
						<td>External/Internal/Condition</td>
						<td>No</td>
						<td></td>
						<td></td>
					</tr>
					<tr>
						<td>
							<code>message.</code>
							<emphasis>property</emphasis>
						</td>
						<td>Yes</td>
						<td>Any type</td>
						<td>
							Where
							<emphasis>property</emphasis>
							is any identifier other than target, selector, sender, server, or self. Message properties
							will be carried over to the next filter. They can contain any type, how these properties are
							interpreted is up to the filter type using them.
						</td>
					</tr>
					<tr>
						<td>
							<code>filter.</code>
							<emphasis>property</emphasis>
						</td>
						<td>Yes</td>
						<td>Any type</td>
						<td>
							The filter arguments can contain any value, it is up to the filter type to interpreter them.
						</td>
					</tr>
				</tbody>
			</table>

			<section>
				<title>The Message and Filter Structures</title>
				<para>
					In the assignment part there are two special structures:
					<code>message.</code>
					<emphasis>property</emphasis>
					and
					<code>filter.</code>
					<emphasis>property</emphasis>
					. Where property is an identifier specifying which property to set. The message structure contains
					some reserved names, but other than that all identifiers can be used.
				</para>
				<para>
					The message structure can be used to pass certain information on to other filters. The other filters
					must ofcourse be aware of these properties and how to interpret these values.
				</para>
				<para>
					The filter structure is in fact nothing more than local access to the filter arguments. It can be
					used to override the filter arguments set in the filter definition for a specific filter element.
					Other than that it is identical to the filter arguments. How the filter arguments are used depends
					on the user filter type. See ... for more information. Filter arguments are not carried on to the
					next filter, they are specific for the current filter. To pass information to other filters you will
					need to use message properties.
				</para>
			</section>

		</section>

		<section xml:id="canonfilters.semantics.fmparams">
			<title>Filter Module Parameters</title>
			<para>
				Filter module parameters can be in the matching expressions and assignment parts. The section will
				explain how the parameters are used. As a reminder, the values for the filter module parameters are
				provided by an external source during the binding. The value types are not strictly defined, it could be
				a literal but also a program element. A single filter module parameter is prefixed with a single
				question mark
				<code language="composestar">?singleFMP</code>
				, and a filter module parameter list is prefixed with two question marks
				<code language="composestar">??fmpList</code>
				. The filter module parameter list can contain different value types.
			</para>

			<section>
				<title>Matching Expression</title>
				<para>
					Filter module parameters can only be used on the right hand side of compare statements. A filter
					module parameter list will be regarded just like a list construction. When a filter module parameter
					is used in a list all values of the filter module parameter are added to the list. For example: we
					have the following filter module parameters:
					<code language="composestar">?fmp = 'foo'; ??lst = ['bar', 'quux'];</code>
					And the following matching expression:
					<programlisting language="composestar"><![CDATA[(selector == ?fmp) | 
(selector == ??lst) |
(selector == ['item', ?fmp]) |
(selector == ['item', ??lst]) |
(selector == ['item', ?fmp, ??lst])]]></programlisting>
					This will internally be interpreted as:
					<programlisting language="composestar"><![CDATA[(selector == 'foo') | 
(selector == ['bar', 'quux']) |
(selector == ['item', 'foo']) |
(selector == ['item', 'bar', 'quux']) |
(selector == ['item', 'foo', 'bar', 'quux'])]]></programlisting>
				</para>
				<para>
					The matching operators expect certain types to be on the right hand side. However, filter module
					parameters can contain any type. When the filter module parameters are processed only compatible
					values will be used, the other values are silently ignored. When the filter module does not contain
					a single compatible type a warning will be issued, in this case the compare statement will result in
					a constant
					<code>false</code>
					. See ... for information about what value types the compare operators expect.
				</para>
			</section>
		</section>

	</section>

	<section xml:id="canonfilters.examples">
		<title>Examples</title>
		<example>
			<title>Example of canonical filters</title>
			<programlisting language="composestar"><![CDATA[filtermodule FM1 (?type, ??methods)
{
	internals
		foo : ?type;
	conditions
		isActive : foo.isActive();
	inputfilters
		toFoo : Dispatch = (
				(!isActive & selector == "activate")
				| (isActive & selector == ??methods & selector %= foo)
			)
			{
				target = foo;
			};
		raiseError : Exception = (selector == ??methods) 
			{
				filter.exception = "Example.Exception.InactiveException"; 
			}
}]]></programlisting>
		</example>
	</section>

	<section xml:id="canonfilters.conversion">
		<title>Conversion</title>
		<para>Below are some examples how to convert the classical notation to the canonical definition.</para>

		<informalexample>
			<programlisting language="composestar"><![CDATA[Dispatch = { [*.bar] *.quux }]]></programlisting>
			<programlisting language="composestar"><![CDATA[Dispatch = (selector == 'bar') { selector = 'quux'; } ]]></programlisting>
		</informalexample>
		<para>
			The classic notation does not force a matching on the target, so the target is not included in the
			expression. In the classic notation
			<code>bar</code>
			and
			<code>quux</code>
			are literals and not variables, in the canonical notation they should be written as literals.
		</para>

		<informalexample>
			<programlisting language="composestar"><![CDATA[Dispatch = { True ~> [*.bar] *.quux }]]></programlisting>
			<programlisting language="composestar"><![CDATA[Dispatch = (!(selector == 'bar')) { selector = 'quux'; }]]></programlisting>
		</informalexample>
		<para>The disable operator is easily substituted with a not operator in the matching expression.</para>

		<informalexample>
			<programlisting language="composestar"><![CDATA[Dispatch = { [*.bar] foo.* }]]></programlisting>
			<programlisting language="composestar"><![CDATA[Dispatch = (selector == 'bar') { target = foo; }]]></programlisting>
		</informalexample>
		<para>
			<code>foo</code>
			is declared as either and internal or external.
		</para>

		<informalexample>
			<programlisting language="composestar"><![CDATA[Dispatch = { <foo.*> foo.* }]]></programlisting>
			<programlisting language="composestar"><![CDATA[Dispatch = (selector %= foo) { target = foo; }]]></programlisting>
		</informalexample>
		<para>Signature matching is performed between a selector and an object.</para>

		<informalexample>
			<programlisting language="composestar"><![CDATA[Dispatch = { c1 | c2 => [*.bar] }]]></programlisting>
			<programlisting language="composestar"><![CDATA[Dispatch = ((c1 | c2) & selector == 'bar')]]></programlisting>
		</informalexample>
		<para>
			The assignment part can often be empty because the filter does not rely on assignments to be made. When the
			assignment part is empty is can also be omitted in the canonical notation.
		</para>

		<informalexample>
			<programlisting language="composestar"><![CDATA[Dispatch = { [*.bar] *.quux, [*.quux] *.bar }]]></programlisting>
			<programlisting language="composestar"><![CDATA[Dispatch = (selector == 'bar') { selector = 'quux'; } 
		cor (selector == "quux") { selector = "bar"; }]]></programlisting>
		</informalexample>
		<para>This example shows how to define multiple filter elements with a single filter.</para>

		<informalexample>
			<programlisting language="composestar"><![CDATA[Dispatch = { {[*.bar], [*.baz]} *.quux }]]></programlisting>
			<programlisting language="composestar"><![CDATA[Dispatch = (selector == 'bar' | selector == 'baz') { selector = 'quux'; }
// or
Dispatch = (selector == ['bar', 'baz']) { selector = 'quux'; }]]></programlisting>
		</informalexample>
		<para>
			Matching different selectors can be done by using either a list of selectors or by writing the complete
			matching expression. Both notations have exactly the same effect.
		</para>

		<informalexample>
			<programlisting language="composestar"><![CDATA[Before = { [*.bar] foo.quux }]]></programlisting>
			<programlisting language="composestar"><![CDATA[Before = ( selector == "bar" ) { filter.target = foo; filter.selector = "quux"; }]]></programlisting>
		</informalexample>
		<para>
			The
			<type>Before</type>
			filter executes a defined method, it does not substitute anything in the message. Previously the
			substitution part was used to provide what method should be called.
		</para>

		<informalexample>
			<programlisting language="composestar"><![CDATA[Exception(exception="java.lang.UnsupportedMethod") = { [*.bar] }]]></programlisting>
			<programlisting language="composestar"><![CDATA[Exception = (selector == "bar") { filter.exception = "java.lang.UnsupportedMethod"; }
// or
Exception(exception="java.lang.UnsupportedMethod") = ( selector == "bar" )]]></programlisting>
		</informalexample>
		<para>
			With canonical filters the filter arguments can be set in the assignment part. But they can also be given as
			arguments directly. In the latter case the argument will apply to all filter elements, while in the former
			case it will only apply to the current filter element.
		</para>

	</section>

	<section xml:id="canonfilters.faq">
		<title>FAQ</title>
		<para></para>
	</section>

</chapter>
