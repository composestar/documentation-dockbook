<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://docbook.org/ns/docbook ../../lib/docbook-5/xsd/docbook.xsd " xml:id="filtercomp">
	<title>Filter Composition</title>
	<para>
		The following is based on the filter composition as discussed in Pascal D&#xFC;rr's PhD thesis in section 6.3.
	</para>
	<para>
		D&#xFC;rr proposes a new language construction for the Compose* language where new filter types are defined
		through a composition of atomic filter types. An example of such a composition is listed in ...
	</para>
	<example>
		<title>Filter Composition of TracingIn</title>
		<programlisting language="composestar"><![CDATA[compositions {
	compose TracingIn of filters:
		SetVariable(variable:!thetarget, property:target),
		SetVariable(variable:!theselector, property:selector),
		SetVariable(variable:!theargs, property:arguments),
		Advice(target:"tracer", selector:"traceOut", 
			tracetarget:!thetarget,	traceselector:!theselector, 
			args:!theargs);
}]]></programlisting>
	</example>
	<para>
		This notation assumes that there is no canonical filter notation. For sake of clarity the example is rewritten
		to conform the notation style as used by the canonical filter notations.
	</para>
	<example>
		<title>Filter Composition of TracingIn (update)</title>
		<programlisting language="composestar"><![CDATA[compositions {
	compose TracingIn of filters:
		SetVariable(variable='thetarget'; property=target),
		SetVariable(variable='theselector'; property=selector),
		SetVariable(variable='theargs'; property=arguments),
		Advice(target='tracer'; selector='traceIn'; 
			tracetarget=message.thetarget; 
			traceselector=message.theselector, args=message.theargs);
}]]></programlisting>
	</example>
	<para>
		Of course this could be even more reduce to a single statement because direct access to the target and selector
		is possible. But we do not optimize this composition even further for sake of a proper example.
	</para>
	<para>
		The notation proposed by D&#xFC;rr introduces new logic and language constructions which I think are not needed.
		Assuming Compose* is fully equipped with the notion of canonical filters and filter module parameters the
		composition of new filter types can be done by making use of filter module as filter types. See
		<xref xlink:href="#filtercomp.ex3" />
		.
	</para>
	<example xml:id="filtercomp.ex3">
		<title>Filter module as filter type</title>
		<programlisting language="composestar"><![CDATA[
concern TracingFilters
{
	filtermodule TracingIn(?tracer, ?traceMethod)
	{
		inputfilters
			setvars : SetVariable = (true) { 
				message.thetarget = target;
				message.theselector = selector;
				message.theargs = message.arguments;
			};
			trace : Advice = (true) {
				filter.target = ?tracer;
				filter.selector = ?traceMethod;
				filter.tracetarget = message.thetarget;
				filter.traceselector = message.theselector;
				filter.args = message.theargs;
			}
	}
	
	filtermodule TracingOut(?tracer, ?traceMethod)
	{
		// ...
	}
}		
		]]></programlisting>
	</example>

	<para>
		The defined filters always match, matching to specific targets and selectors is left to the user of this filter
		module as filter type. The tracer parameter should be an object instance and the traceMethod parameter is the
		method in that object that should be called. Note that the setvars filter is not really needed because direct
		access to these variables is possible.
	</para>
	<para>
		When this filter module is used these arguments must be provided.
		<xref xlink:href="#filtercomp.ex4" />
		shows how this filter type can be used. Because filter modules are a bit different than ordinary filter types
		they are prefixed with an @ followed by the fully qualified name of the filter module.
	</para>

	<example xml:id="filtercomp.ex4">
		<title>Using a filter module as filter type</title>
		<programlisting language="composestar"><![CDATA[
concern TracingConcern
{
	filtermodule TracingModule
	{
		externals
			tracer : TracingLib.Tracer = TracingLib.Tracer.Instance;
		conditions
			shouldTrace : tracer.shouldTrace;
		inputfilters
			tracingIn : @TracingFilters.TracingIn(tracer, 'traceIn') =
				(shouldTrace)
		outputfilters 
			tracingOut: @TracingFilters.TracingOut(tracer, 'traceOut') =
				(shouldTrace)
	}
}		
		]]></programlisting>
	</example>

	<para>
		To make the notation a bit less verbose filter modules could be imported using an import statement like follows:
		<programlisting><![CDATA[
concern TracingConcern
{
	importfilters
	{ 
		TracingFilters.*;
	}

	filtermodule TracingModule
	{
		// ...	
		inputfilters
			tracingIn : @TracingIn(tracer, 'traceIn') =
				(shouldTrace)
		outputfilters 
			tracingOut: @TracingOut(tracer, 'traceOut') =
				(shouldTrace)
	
	}
}
		]]></programlisting>
	</para>

</chapter>
